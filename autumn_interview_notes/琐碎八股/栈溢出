✅ 1. 什么是“栈溢出”？
栈溢出 = 程序把栈区用爆了，栈指针越界，进入非法内存区域，操作系统会终止程序。

在 Linux 上表现为：
Segmentation fault (core dumped)
✅ 2. 常见栈溢出触发方式（例子）
🔸 a. 无限递归
void f() { f(); }
int main() {
    f();
}
每次调用函数都会在栈上分配 return 地址、局部变量
无限递归导致调用栈层层堆叠
栈空间用光 → 段错误 SIGSEGV
---------------------------------------------------------------------------------
✅ 1. SIGSEGV 是啥？
全称：

SIGSEGV = Signal: Segmentation Violation
中文解释：
段错误信号，表示程序访问了它不应该访问的内存地址段（segment）
---------------------------------------------------------------------
✅ 2. “段（Segment）”是啥意思？
在操作系统层面，程序的内存是被分为多个逻辑区域（段）：

段（Segment）	存什么？
.text	可执行代码（只读）
.data	初始化的全局变量
.bss	未初始化的全局变量
stack	函数调用、局部变量
heap	动态分配内存（new/malloc）
mmap 区域	动态库映射、内存文件

每一段都有访问权限（可读/写/执行），地址范围受到操作系统保护。

--------------------------------------------------------------
✅ 3. 什么叫“段错误”？
段错误 = 访问了自己不拥有的段地址（比如你想写只读段、解引用空指针、栈溢出）

系统表现：
Linux 内核检测到非法访问

发送 SIGSEGV 信号给当前进程

程序被杀死，终止执行
--------------------------------------------------------------
✅ 4. 常见导致 SIGSEGV 的场景：
错误场景	示例代码	解释
❌ 访问空指针	int* p = NULL; *p = 10;	NULL 地址未映射，非法写入
❌ 栈溢出	无限递归、栈上分配大数组	栈用光，访问了不属于它的段
❌ 数组越界	int a[10]; a[100] = 1;	越界访问别的段
❌ 写只读段	char* s = "hi"; s[0] = 'H';	字面量存在 .rodata 段（只读）
❌ 释放后使用内存	free(ptr); *ptr = 1;	堆块被系统回收后，变成未映射段








