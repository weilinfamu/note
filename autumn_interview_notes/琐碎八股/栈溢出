✅ 1. 什么是“栈溢出”？
栈溢出 = 程序把栈区用爆了，栈指针越界，进入非法内存区域，操作系统会终止程序。

在 Linux 上表现为：
Segmentation fault (core dumped)
✅ 2. 常见栈溢出触发方式（例子）
🔸 a. 无限递归
void f() { f(); }
int main() {
    f();
}
每次调用函数都会在栈上分配 return 地址、局部变量
无限递归导致调用栈层层堆叠
栈空间用光 → 段错误 SIGSEGV
---------------------------------------------------------------------------------
✅ 1. SIGSEGV 是啥？
全称：

SIGSEGV = Signal: Segmentation Violation
中文解释：
段错误信号，表示程序访问了它不应该访问的内存地址段（segment）
---------------------------------------------------------------------
✅ 2. “段（Segment）”是啥意思？
在操作系统层面，程序的内存是被分为多个逻辑区域（段）：

段（Segment）	存什么？
.text	可执行代码（只读）
.data	初始化的全局变量
.bss	未初始化的全局变量
stack	函数调用、局部变量
heap	动态分配内存（new/malloc）
mmap 区域	动态库映射、内存文件

每一段都有访问权限（可读/写/执行），地址范围受到操作系统保护。

--------------------------------------------------------------
✅ 3. 什么叫“段错误”？
段错误 = 访问了自己不拥有的段地址（比如你想写只读段、解引用空指针、栈溢出）

系统表现：
Linux 内核检测到非法访问

发送 SIGSEGV 信号给当前进程

程序被杀死，终止执行
--------------------------------------------------------------
✅ 4. 常见导致 SIGSEGV 的场景：
错误场景	示例代码	解释
❌ 访问空指针	int* p = NULL; *p = 10;	NULL 地址未映射，非法写入
❌ 栈溢出	无限递归、栈上分配大数组	栈用光，访问了不属于它的段
❌ 数组越界	int a[10]; a[100] = 1;	越界访问别的段
❌ 写只读段	char* s = "hi"; s[0] = 'H';	字面量存在 .rodata 段（只读）
❌ 释放后使用内存	free(ptr); *ptr = 1;	堆块被系统回收后，变成未映射段

✅ 6. 常见面试题：SIGSEGV 和如何避免
题目	回答要点
什么是段错误？	非法访问内存段，操作系统发 SIGSEGV 信号终止进程
如何触发 SIGSEGV？	NULL 指针、栈溢出、堆越界、只读段写
如何调试 SIGSEGV？	gdb core → bt → frame
如何防止？	初始化指针、加范围检查、用智能指针、ASAN 工具


----------------------------------------------------------------------------------------------------------------------------
🔸 b. 栈上数组过大（局部分配超范围）
int main() {
    int big_array[1024 * 1024 * 100]; // 约 400MB，远超默认栈大小
    big_array[0] = 1;
}

Linux 默认栈大小一般是 8MB（可以用 ulimit -s 查看），上面会崩。
----------------------------------------------------------------------------------------------------------------------------------------------


🔸 c. 栈上死循环写入局部变量（手动覆盖栈）
int main() {
    char x[10];
    for (int i = 0; ; ++i)
        x[i] = 'A';  // 越界写，最终栈溢出
}
--------------------------------------------------------------------------------------------------------------------------------------------------
✅ 3. 程序崩溃表现（Linux）
访问了栈底下的非法内存（OS 会保护栈底页）
内核捕获到非法内存访问，发送 SIGSEGV

---------------------------------------------------------------------------------------
✅ 4. 如何调试栈溢出？
你可以使用：
ulimit -c unlimited       # 启用 core dump
./a.out                   # 执行程序
gdb ./a.out core
(gdb) bt                  # 查看哪个函数/第几层崩溃
✅ 示例（无限递归）

void boom(int i) {
    int a[100];
    boom(i + 1);
}

int main() {
    boom(0);
}
调试输出：

Segmentation fault (core dumped)
gdb ./a.out core
(gdb) bt
#0 boom()
#1 boom()
#2 boom()
#3 boom()
...
#10000 boom()
你能看到调用栈非常深（几千层），说明栈空间被用尽。
---------------------------------------------------------------------------------------
✅ 三、开启 core dump 的方法
Linux 默认不保存 core 文件，需要先运行：
ulimit -c unlimited
📌 解释：
ulimit：是 Linux shell 的资源限制命令

-c unlimited：表示允许生成任意大小的 core 文件（也就是启用 core dump）

✅ 四、重新运行程序：
./a.out
你会看到和之前一样：
Segmentation fault (core dumped)
这时，会生成一个 core 文件（比如 core 或 core.1234）
✅ 五、使用 GDB 调试 core 文件
gdb ./a.out core
(gdb) bt
这表示 backtrace —— 回溯当前线程的调用栈：
#0 boom()
#1 boom()
#2 boom()
#3 boom()
...
#10000 boom()

---------------------------------------------------------------------------------------



