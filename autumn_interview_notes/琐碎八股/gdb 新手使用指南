你已经有了带调试信息的程序：
g++ -g exercise.cpp -o exercise.out -pthread

🧩 第一步：启动 gdb
gdb exercise.out
进入后会看到：
(gdb) 


----------------------------------------------------------
rc@DESKTOP-NIB59HE:~/实现各种算法$ gdb exercise.out
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.2) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.

(gdb) (gdb) run              # 启动程序
Undefined command: "".  Try "help".
(gdb) run              # 启动程序
Starting program: /home/rc/实现各种算法/exercise.out # 启动程序
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7ffff7d9f700 (LWP 22828)]
Produced: 83
[New Thread 0x7ffff759e700 (LWP 22829)]
Consumed: 83
Produced: 86
Consumed: 86
Produced: 77
Consumed: 77
Produced: 15
^C
Thread 1 "exercise.out" received signal SIGINT, Interrupt.
__pthread_clockjoin_ex (threadid=140737351644928, thread_return=0x0, clockid=<optimized out>, abstime=<optimized out>, 
    block=<optimized out>) at pthread_join_common.c:145
145     pthread_join_common.c: No such file or directory.
(gdb) 
--------------------------------------------------------------------------------------------------------------------
(gdb) run
🔹 意思：
运行当前加载的程序（exercise.out）
会重启程序，从 main() 开始执行
是 gdb 最基本的命令之一
--------------------------------------------------------------------------------------------------------------------
✅ 输出：启动程序并附加线程调试支持
Starting program: /home/rc/实现各种算法/exercise.out
启动程序的路径。
说明你的程序已经被加载、准备开始运行。

[Thread debugging using libthread_db enabled]
gdb 加载了专门的库 libthread_db，用于调试 pthread 线程程序。
✅ 自动完成，无需担心。
--------------------------------------------------------------------------------------------------------------------
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1"
指明所用的调试库实际加载的是哪个动态链接库。

--------------------------------------------------------------------------------------------------------------------
✅ 输出：线程启动

[New Thread 0x7ffff7d9f700 (LWP 22828)]
Produced: 83
启动了一个新线程（就是 producer）

LWP 是 Linux Light Weight Process（轻量级线程）

线程号是 22828，内核级线程

然后 producer 执行了 printf("Produced: %d\n", buffer);

------------------------------------------------------------------------------------------------------------
✅ 你按下了 Ctrl+C，gdb 输出：
^C
Thread 1 "exercise.out" received signal SIGINT, Interrupt.
你打断了程序（通常是要暂停调试、查看状态）
SIGINT 信号是 Ctrl+C 在 Linux 下发出的终止信号
__pthread_clockjoin_ex (threadid=140737351644928, ...)
at pthread_join_common.c:145

显示当前暂停的位置：主线程（main）正在等待其他线程结束（pthread_join）
pthread_join 是在 main() 中等待生产者/消费者线程完成的函数

------------------------------------------------------------------------------------------------------------
✅ 什么是 libthread_db.so？
libthread_db.so 是 Linux 上专门用于 GDB 调试 pthread 多线程程序的共享库（调试支持库）。

它不是你程序直接链接的库，而是 gdb 用来“看清楚线程内部状态”的“外挂眼镜”。

✅ “host” 是什么？
host = 当前运行 GDB 的主机操作系统环境（即本地 Linux）
表示：你本地系统 /lib/x86_64-linux-gnu/ 中的这个库正被用来支持 gdb 分析线程。


------------------------------------------------------------------------------------------------------------
 为什么要这个库？
POSIX 线程（pthread）是内核调度的实体（LWP），但 GDB 不直接能“看懂”线程结构。
所以 GDB 借助 libthread_db 来获得以下信息：
活动线程列表
每个线程的栈、寄存器
哪个线程卡在哪个锁、在哪个系统调用
[gdb] ← 使用 → [libthread_db.so.1] ← 解释 → [线程库的内部状态（libpthread.so）]
------------------------------------------------------------------------------------------------------------
✅ 2. SIGINT 是通过线程发出的吗？pthread_join 是怎么卡住的？
✅ 首先明确：
SIGINT 是一个信号（Signal）
Ctrl+C 是 shell 发送给前台进程组的 SIGINT 信号
不管你用不用多线程，都会触发这个信号。
------------------------------------------------------------------------------------------------------------
信号是进程级别的，内核直接发给进程（无视线程细节）
------------------------------------------------------------------------------------------------------------
📌 gdb 为什么能告诉你 pthread_join_common.c:145？
因为你用了 -g 编译选项，GDB 能解析带源码路径的系统库。

如果库是 -g 编译的，就能看到源码级信息。

------------------------------------------------------------------------------------------------------------
✅ 1. 是的，这是真实存在的系统源码文件
pthread_join_common.c 是 glibc 库中的源文件
Glibc 是 Linux 上 C 标准库（libc）、线程库（libpthread）的实现者
你调用 pthread_join()，实际上执行的是 glibc 中的真实 C 函数
📍 所以你看到的 pthread_join_common.c:145 指的是 glibc 中这个文件第 145 行的代码。

------------------------------------------------------------------------------------------------------------
🧩 6. set scheduler-locking on — 锁定当前线程
默认 GDB 会调度多个线程交替执行。

(gdb) set scheduler-locking on
表示只让当前线程执行，其余全部挂起，适合分析 race condition（竞态）

------------------------------------------------------------------------------------------------------------
🧩 7. finish — 直接跳出当前函数

(gdb) finish
跳出当前函数、返回调用者，可以加速调试。
------------------------------------------------------------------------------------------------------------
✅ 一、基础调试命令（每个 C/C++ 程序员必会）
命令	作用
run / r	启动程序
break / b	设置断点（函数名、文件:行号）
continue / c	继续执行到下一个断点
next / n	单步执行（不进入函数）
step / s	单步执行（进入函数）
print x / p x	打印变量 x 的值
list / l	查看源代码
quit / q	退出 gdb
---------------------------------
✅ 每项重点举例（部分高频技巧）
✅ watch buffer 监控写入

(gdb) watch buffer
(gdb) run
程序一旦修改 buffer（无论哪个线程），立即暂停：


Hardware watchpoint 1: buffer
Old value = 42
New value = 50
✅ 条件断点 condition

(gdb) break producer
(gdb) condition 1 buffer == 88
只有当 buffer == 88 时才断下，非常适合调试不稳定的竞态值。

✅ info threads + bt

(gdb) info threads
(gdb) thread 3
(gdb) bt
看第 3 个线程是否卡在 sem_wait、死锁、sleep 等地方。

✅ x（examine memory）

(gdb) x/4x &buffer
查看内存中变量 buffer 的十六进制内容。

✅ 汇编分析：

(gdb) disassemble producer
查看函数汇编结构，分析优化、指令级行为。

✅ call 注入调用：

(gdb) call printf("X = %d\n", buffer)
直接运行函数调用调试输出，不改代码。

✅ layout（图形 TUI）

(gdb) layout src
(gdb) layout asm
全屏显示源码 + 汇编，适合交互式可视化调试。

-------------------------------------------------------
初级	断点 + 打印 + 单步	break, run, next, print, quit
中级	条件 + watch + 多线程	watch, condition, info threads, bt
高级	汇编、寄存器、patch	disas, x, info reg, set *(...) =
实战	core dump, 共享库调试	gdb ./a.out core, info sharedlibrary
自动	.gdbinit, define, source	自动调试脚本、自定义命令
-----------------------------------------------------------





