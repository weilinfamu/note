你已经有了带调试信息的程序：
g++ -g exercise.cpp -o exercise.out -pthread

🧩 第一步：启动 gdb
gdb exercise.out
进入后会看到：
(gdb) 


----------------------------------------------------------
rc@DESKTOP-NIB59HE:~/实现各种算法$ gdb exercise.out
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.2) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.

(gdb) (gdb) run              # 启动程序
Undefined command: "".  Try "help".
(gdb) run              # 启动程序
Starting program: /home/rc/实现各种算法/exercise.out # 启动程序
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7ffff7d9f700 (LWP 22828)]
Produced: 83
[New Thread 0x7ffff759e700 (LWP 22829)]
Consumed: 83
Produced: 86
Consumed: 86
Produced: 77
Consumed: 77
Produced: 15
^C
Thread 1 "exercise.out" received signal SIGINT, Interrupt.
__pthread_clockjoin_ex (threadid=140737351644928, thread_return=0x0, clockid=<optimized out>, abstime=<optimized out>, 
    block=<optimized out>) at pthread_join_common.c:145
145     pthread_join_common.c: No such file or directory.
(gdb) 
--------------------------------------------------------------------------------------------------------------------
(gdb) run
🔹 意思：
运行当前加载的程序（exercise.out）
会重启程序，从 main() 开始执行
是 gdb 最基本的命令之一
--------------------------------------------------------------------------------------------------------------------
✅ 输出：启动程序并附加线程调试支持
Starting program: /home/rc/实现各种算法/exercise.out
启动程序的路径。
说明你的程序已经被加载、准备开始运行。

[Thread debugging using libthread_db enabled]
gdb 加载了专门的库 libthread_db，用于调试 pthread 线程程序。
✅ 自动完成，无需担心。
--------------------------------------------------------------------------------------------------------------------
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1"
指明所用的调试库实际加载的是哪个动态链接库。

--------------------------------------------------------------------------------------------------------------------
✅ 输出：线程启动

[New Thread 0x7ffff7d9f700 (LWP 22828)]
Produced: 83
启动了一个新线程（就是 producer）

LWP 是 Linux Light Weight Process（轻量级线程）

线程号是 22828，内核级线程

然后 producer 执行了 printf("Produced: %d\n", buffer);

------------------------------------------------------------------------------------------------------------
✅ 你按下了 Ctrl+C，gdb 输出：
^C
Thread 1 "exercise.out" received signal SIGINT, Interrupt.
你打断了程序（通常是要暂停调试、查看状态）
SIGINT 信号是 Ctrl+C 在 Linux 下发出的终止信号
__pthread_clockjoin_ex (threadid=140737351644928, ...)
at pthread_join_common.c:145

显示当前暂停的位置：主线程（main）正在等待其他线程结束（pthread_join）
pthread_join 是在 main() 中等待生产者/消费者线程完成的函数

------------------------------------------------------------------------------------------------------------
✅ 什么是 libthread_db.so？
libthread_db.so 是 Linux 上专门用于 GDB 调试 pthread 多线程程序的共享库（调试支持库）。

它不是你程序直接链接的库，而是 gdb 用来“看清楚线程内部状态”的“外挂眼镜”。

✅ “host” 是什么？
host = 当前运行 GDB 的主机操作系统环境（即本地 Linux）
表示：你本地系统 /lib/x86_64-linux-gnu/ 中的这个库正被用来支持 gdb 分析线程。


------------------------------------------------------------------------------------------------------------
 为什么要这个库？
POSIX 线程（pthread）是内核调度的实体（LWP），但 GDB 不直接能“看懂”线程结构。
所以 GDB 借助 libthread_db 来获得以下信息：
活动线程列表
每个线程的栈、寄存器
哪个线程卡在哪个锁、在哪个系统调用
[gdb] ← 使用 → [libthread_db.so.1] ← 解释 → [线程库的内部状态（libpthread.so）]
------------------------------------------------------------------------------------------------------------
✅ 2. SIGINT 是通过线程发出的吗？pthread_join 是怎么卡住的？
✅ 首先明确：
SIGINT 是一个信号（Signal）
Ctrl+C 是 shell 发送给前台进程组的 SIGINT 信号
不管你用不用多线程，都会触发这个信号。
------------------------------------------------------------------------------------------------------------
信号是进程级别的，内核直接发给进程（无视线程细节）
------------------------------------------------------------------------------------------------------------
📌 gdb 为什么能告诉你 pthread_join_common.c:145？
因为你用了 -g 编译选项，GDB 能解析带源码路径的系统库。

如果库是 -g 编译的，就能看到源码级信息。

------------------------------------------------------------------------------------------------------------

