
----------------------------------------------------------------------------------------
✅ .o 和 .out 是完全不同的阶段产物
类型	文件扩展名	阶段	内容	能不能运行？
目标文件	.o	编译阶段	每个 .cpp 编译后的中间产物	❌ 不能执行
可执行文件	.out / 无扩展	链接后产物	最终可运行程序（已链接 libc、main）	✅ 可以运行

----------------------------------------------------------------------------------------
✅ 编译流程分两步（也可一步完成）
步骤 1：编译（compile）

g++ -c exercise.cpp -o exercise.o
-c 表示只编译，不链接

结果是 .o：机器码 + 符号，但还不能运行
----------------------------------------------------------------------------------------
步骤 2：链接（link）
g++ exercise.o -o exercise.out
把 .o + 系统库 + 运行时库 链接起来
形成 可执行文件
.out 是习惯命名，你可以用任意名字，比如 myapp、main.exe 都行
----------------------------------------------------------------------------------------
或者一步完成：

g++ exercise.cpp -o exercise.out
这其实等价于：

g++ -c exercise.cpp -o exercise.o
g++ exercise.o -o exercise.out
----------------------------------------------------------------------------------------
✅ 图解：从 .cpp 到可执行程序
[C++ 源文件]
   ↓ g++ -c
[.o 目标文件]  ❌ 不能执行
   ↓ g++ + 链接器
[exercise.out] ✅ 真正能执行
----------------------------------------------------------------------------------------
✅ 如果你只写 .o，运行会发生什么？

g++ -c exercise.cpp
./exercise.o  # ❌ 会报错：不是有效的可执行文件
这是因为 .o 只是中间机器码，不包含入口函数、运行时、libc 链接等信息。

----------------------------------------------------------------------------------------

.out 文件是最终可执行文件，可以运行；
.o 文件是中间产物，不能运行；
所以 g++ exercise.cpp -o exercise.out 是非常合理的命令，它完成了编译 + 链接。
----------------------------------------------------------------------------------------
先编译 .cpp
请先用下面的命令编译成可执行文件：
# 编译生成 exercise.out
g++ exercise.cpp -o exercise.out

然后你就可以：
readelf -S exercise.out  # ✅ 查看段信息

gdb exercise.out  # ✅ 调试
✅ 那和 gdb 有什么关系？
gdb 调试的是可执行文件（.out），不是 .cpp。它从 .out 中提取以下内容：

.text → 反汇编查看函数
.data/.bss → 查看变量地址和值
带调试符号的编译：使用 -g 可以看到变量名、源代码行号等

gdb 调试的是可执行文件（.out），不是 .cpp。它从 .out 中提取以下内容：
.text → 反汇编查看函数
.data/.bss → 查看变量地址和值
带调试符号的编译：使用 -g 可以看到变量名、源代码行号等

---------------------------------------------------------------------------------
g++ -g exercise.cpp -o exercise.out
gdb exercise.out

(gdb) info variables
(gdb) disassemble main
(gdb) break main
(gdb) run
(gdb) print &your_var
---------------------------------------------------------------------------------
补：确认当前目录下是否存在 .out 文件
ls -l *.out
看看有没有文件；如果都没有，那就一定是还没编译成功。
---------------------------------------------------------------------------------






