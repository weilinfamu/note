
----------------------------------------------------------------------------------------
✅ .o 和 .out 是完全不同的阶段产物
类型	文件扩展名	阶段	内容	能不能运行？
目标文件	.o	编译阶段	每个 .cpp 编译后的中间产物	❌ 不能执行
可执行文件	.out / 无扩展	链接后产物	最终可运行程序（已链接 libc、main）	✅ 可以运行

----------------------------------------------------------------------------------------
✅ 编译流程分两步（也可一步完成）
步骤 1：编译（compile）

g++ -c exercise.cpp -o exercise.o
-c 表示只编译，不链接

结果是 .o：机器码 + 符号，但还不能运行
----------------------------------------------------------------------------------------
步骤 2：链接（link）
g++ exercise.o -o exercise.out
把 .o + 系统库 + 运行时库 链接起来
形成 可执行文件
.out 是习惯命名，你可以用任意名字，比如 myapp、main.exe 都行
----------------------------------------------------------------------------------------
或者一步完成：

g++ exercise.cpp -o exercise.out
这其实等价于：

g++ -c exercise.cpp -o exercise.o
g++ exercise.o -o exercise.out
----------------------------------------------------------------------------------------
✅ 图解：从 .cpp 到可执行程序
[C++ 源文件]
   ↓ g++ -c
[.o 目标文件]  ❌ 不能执行
   ↓ g++ + 链接器
[exercise.out] ✅ 真正能执行
----------------------------------------------------------------------------------------
✅ 如果你只写 .o，运行会发生什么？

g++ -c exercise.cpp
./exercise.o  # ❌ 会报错：不是有效的可执行文件
这是因为 .o 只是中间机器码，不包含入口函数、运行时、libc 链接等信息。






