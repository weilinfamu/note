é€’å½’ä¸‰éƒ¨æ›²ï¼š
1ï¼šç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°ä»¥åŠè¿”å›žå€¼
2ï¼šç¡®å®šç»ˆæ­¢æ¡ä»¶
3ï¼šç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘
e.g:
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        // é¦–å…ˆæŽ’é™¤ç©ºèŠ‚ç‚¹çš„æƒ…å†µ
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        // æŽ’é™¤äº†ç©ºèŠ‚ç‚¹ï¼Œå†æŽ’é™¤æ•°å€¼ä¸ç›¸åŒçš„æƒ…å†µ
        else if (left->val != right->val) return false;

        // æ­¤æ—¶å°±æ˜¯ï¼šå·¦å³èŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºï¼Œä¸”æ•°å€¼ç›¸åŒçš„æƒ…å†µ
        // æ­¤æ—¶æ‰åšé€’å½’ï¼Œåšä¸‹ä¸€å±‚çš„åˆ¤æ–­
        bool outside = compare(left->left, right->right);   // å·¦å­æ ‘ï¼šå·¦ã€ å³å­æ ‘ï¼šå³
        bool inside = compare(left->right, right->left);    // å·¦å­æ ‘ï¼šå³ã€ å³å­æ ‘ï¼šå·¦
        bool isSame = outside && inside;                    // å·¦å­æ ‘ï¼šä¸­ã€ å³å­æ ‘ï¼šä¸­ ï¼ˆé€»è¾‘å¤„ç†ï¼‰
        return isSame;

    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return compare(root->left, root->right);
    }
};

æ³¨æ„ï¼Œé€’å½’æ˜¯å®Œå…¨æ³¨é‡ç­›é€‰çš„ï¼Œå› æ­¤ï¼Œä¿©return ... æœ€åŽä¸€ä¸ªæ˜¯å›žæº¯æœ€åŽåœ¨æ ˆä¸­returnçš„èµ·ç‚¹ï¼Œé€æ­¥ä¸Šå±‚ï¼Œä¹‹åŽéƒ½æ˜¯åœ¨åˆ¤æ–­è¿™äº›ï¼š

å¸¸è§é”™è¯¯ï¼šä½ é‡åˆ°çš„è¿™ä¸ªæŠ¥é”™æ˜¯éžå¸¸å…¸åž‹çš„é€’å½’åˆ¤æ–­é”™è¯¯ï¼š

âŒ æŠ¥é”™è§£é‡Šï¼ˆçœ‹å›¾ä¸­è¿™å¥ï¼‰ï¼š
cpp
Copy
Edit
if(left->val != right->val) return false;
æŠ¥é”™ä¿¡æ¯ï¼š

txt
Copy
Edit
runtime error: member access within null pointer of type 'TreeNode'
âœ… é”™è¯¯åŽŸå› ï¼š
ä½ åœ¨ æœªåˆ¤æ–­æŒ‡é’ˆæ˜¯å¦ä¸º nullptr çš„å‰æä¸‹ï¼Œç›´æŽ¥è®¿é—®äº†ï¼š

cpp
Copy
Edit
left->val æˆ– right->val
ðŸ”¥ ä¸¾ä¾‹è§¦å‘é”™è¯¯çš„æƒ…å½¢ï¼š
æ¯”å¦‚ä½ é€’å½’åˆ°äº†è¿™æ ·ä¸€å¯¹ï¼š

cpp
Copy
Edit
left = nullptr
right = TreeNode(3)
ä½ ç›´æŽ¥åŽ»è®¿é—® left->valï¼Œç»“æžœå°±æ˜¯ ç©ºæŒ‡é’ˆè§£å¼•ç”¨ â†’ ç¨‹åºå´©æºƒï¼

âœ… æ­£ç¡®é¡ºåºï¼šå¿…é¡»å…ˆåˆ¤æ–­ nullï¼Œå†è®¿é—® val
ä½ çš„é¡ºåºçŽ°åœ¨æ˜¯ï¼š

cpp
Copy
Edit
if(left->val != right->val) return false;  âŒ
æ­£ç¡®é¡ºåºåº”è¯¥æ˜¯ï¼š

cpp
Copy
Edit
if (!left && right) return false;
if (left && !right) return false;
if (!left && !right) return true;
if (left->val != right->val) return false;  // âœ… çŽ°åœ¨æ‰å®‰å…¨
ðŸ“Œ å°å£è¯€å¸®åŠ©ä½ è®°ï¼š
â€œå…ˆåˆ¤ç©ºï¼Œå†æ¯”å€¼ï¼›ä¸åˆ¤ç©ºï¼Œç‚¸ç¨‹åºï¼â€






æ³¨æ„è¿™äº›ä¸ªï¼Œè¿›è¡Œinitçš„æ—¶å€™çš„è¦†ç›–é—®é¢˜äº†ï¼š

â€œ
âœ… é”™è¯¯æ ¸å¿ƒï¼š
ä½ åœ¨è¿™è¡Œé‡Œå†™äº†ä¸€ä¸ªå±€éƒ¨å˜é‡ï¼Œè€Œä¸æ˜¯ç”¨ä½ ä¸Šé¢å£°æ˜Žçš„ resultï¼š

int result = max(depth, result); // âŒ é”™è¯¯ï¼è¿™æ˜¯å±€éƒ¨å˜é‡ result
ðŸ“Œ ä½ ä»¥ä¸ºåœ¨æ›´æ–°å…¨å±€ resultï¼Œä½†å®žé™…ä¸Šä½ æ˜¯ï¼š
å£°æ˜Žäº†ä¸€ä¸ªæ–°çš„ int resultï¼ˆå±€éƒ¨ï¼‰

ç„¶åŽå®ƒç«‹åˆ»è¢«ä¸¢å¼ƒ

å…¨å±€çš„ result æ ¹æœ¬æ²¡è¢«æ›´æ–°ï¼

âœ… æ­£ç¡®åšæ³•ï¼šä¸è¦é‡æ–°å£°æ˜Ž int result
ä½ åº”è¯¥ç›´æŽ¥å†™ï¼š

result = max(depth, result);  // âœ… ä¿®æ”¹ç±»çš„æˆå‘˜å˜é‡ result
â—é™„åŠ é—®é¢˜ï¼š
è¿˜æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼š

int result = 0;
int depth = 1;
ä½ åœ¨ maxDepth() å‡½æ•°å†…éƒ¨åˆå®šä¹‰äº†ä¸€ä¸ªå±€éƒ¨ resultï¼Œè¿™ä¹Ÿä¼šè¦†ç›–ç±»æˆå‘˜å˜é‡ã€‚

æ‰€ä»¥ä½ å®žé™… return çš„ä¹Ÿæ˜¯å±€éƒ¨å˜é‡ï¼
â€


å¯ä»¥å†åšä¸€éè¿™ä¸ªï¼š

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //é€’å½’å†™äº†å¾ˆå¤šé“ï¼Œä¸€ç›´ä¸è¡Œï¼ŒåºŸäº†
    int result;
    void getDepth(TreeNode*node,int depth)
        {   
            result = max(depth,result);
            //è¿™é‡Œæ˜¯base condition,ä»Žè¿™é‡Œå°±å¼€å§‹return å›žæº¯
            if(node->left == NULL && node->right == NULL) return;
            
            if(node->left){
                depth++;
                getDepth(node->left,depth);
                depth--;
            }
            if(node->right){
                depth++;
                getDepth(node->right,depth);
                depth--;
            }
        }

    int maxDepth(TreeNode* root) {
      result = 0;
      int depth = 1;
      if(!root)return result;
      getDepth(root,depth);
      return result;
    }
};
